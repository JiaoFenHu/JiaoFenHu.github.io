<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[rabbitMQ学习笔记 - Hello World]]></title>
    <url>%2Fposts%2Frabbitmq%2F1ad863e.html</url>
    <content type="text"><![CDATA[注意：在阅读之前保证你的电脑上已经安装并运行了rabbitMQ如果您使用其他主机，端口或凭据，则叙述过程中连接设置需要进行调整。下面介绍的操作都是基于CentOS7上完成的。rabbitMQ脚本安装教程：rabbitMQ 安装教程 来自官网的简介&emsp;&emsp;RabbitMQ是消息代理：它接受并转发消息。您可以将其视为邮局：将要发布的邮件放在邮箱中时，可以确保 Mail person 先生或女士最终将邮件传递给收件人。以此类推，RabbitMQ是一个邮箱，一个邮局和一个邮递员。RabbitMQ与邮局之间的主要区别在于，它不处理纸张，而是接收，存储和转发数据消息的二进制blob。 RabbitMQ消息队列基础流程： 生产者：发送消息的程序叫生产端。 队&emsp;列：它的名字叫rabbit，它本质上是一个大的消息缓冲器。许多生产者可以发送进入一个队列的消息，许多消费者可以尝试从一个队列接收数据。 消费者：对应生产者，是用来接收生产者发出的消息。 使用 php-amqplib 客户端使用composer进行依赖项管理。官网推荐使用php-amqplib类库，amqplib的github地址将composer.json文件添加到您的项目中：12345&#123; "require" : &#123; "php-amqplib/php-amqplib" : "&gt;=2.6.1" &#125;&#125; 运行composer install命令进行安装。安装完成后项目中会产生一个vendor文件夹，里面包含的有php-amqplib类库 创建生产者（产生消息）在创建生产者之前先创建一个配置文件：config.php代码中主机，端口，用户名及密码根据自己的实际情况进行更换。1234567&lt;?phpdefine('HOST', 'localhost');define('PORT', 5672);define('USER', 'harlan');define('PASS', '123456');define('MQ_NAME', 'hello'); 使用上面安装的php-amqplib类库来创建一个生产者，命名为send.php：1234567891011121314151617181920212223242526&lt;?php// 引入composer自动加载文件及config文件require_once __DIR__ . '/vendor/autoload.php';require_once __DIR__ . '/config.php';// 引入amqp类use PhpAmqpLib\Connection\AMQPStreamConnection;use PhpAmqpLib\Message\AMQPMessage;$connection = new AMQPStreamConnection(HOST, PORT, USER, PASS);$channel = $connection-&gt;channel();// 创建队列通道$channel-&gt;queue_declare(MQ_NAME, false, false, false, false);$msg_str = 'Hello World!';$msg = new AMQPMessage($msg_str);$channel-&gt;basic_publish($msg, '', MQ_NAME);echo ​" [x] Sent " . $msg_str . "\n";// 最后别忘了，断开连接$channel-&gt;close();$connection-&gt;close(); 运行send.php文件：[root@localhost rabbitMQ]# php ./send.php 创建消费者（接收消息）创建一个消费者命名为：receive.php，消费者用来接收生产者所产生的消息。1234567891011121314151617181920212223242526&lt;?php// 引入composer自动加载文件及config文件require_once __DIR__ . '/vendor/autoload.php';require_once __DIR__ . '/config.php';// 引入amqp类use PhpAmqpLib\Connection\AMQPStreamConnection;$connection = new AMQPStreamConnection(HOST, PORT, USER, PASS);$channel = $connection-&gt;channel();$channel-&gt;queue_declare($MQ_NAME, false, false, false, false);echo ​" [*] Waiting for messages. To exit press CTRL+C\n";$callback = function ($msg) &#123; echo ' [x] Received ', $msg-&gt;body, "\n";&#125;;$channel-&gt;basic_consume($MQ_NAME, '', false, true, false, false, $callback);// 没有消息就阻塞while ($channel-&gt;is_consuming()) &#123; $channel-&gt;wait();&#125; 运行receive.php文件：[root@localhost rabbitMQ]# php ./receive.php，发现程序被阻塞等待消息（使用Ctrl-C可以退出）。这时新建一个窗口运行send.php就可以看到效果了。 参考 rabbitMQ官网 - “Hello World”]]></content>
      <categories>
        <category>rabbitmq</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>rabbitmq</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rabbitMQ使用期间可能会遇到的问题 - CentOS 7]]></title>
    <url>%2Fposts%2Frabbitmq%2F79100238.html</url>
    <content type="text"><![CDATA[NOT_ALLOWED - access to vhost ‘/‘ refused for user ‘harlan’原因是因为harlan用户没有访问 ‘/‘ 的权限。 使用下面命令修改权限：rabbitmqctl set_permissions -p / harlan &#39;.*&#39; &#39;.*&#39; &#39;.*&#39; inequivalent arg ‘durable’ for queue ‘hello’ in vhost ‘/‘: received ‘true’ but current is ‘false’原因是因为hello这个队列已经被你定义成非持久化的队列。 $channel-&gt;queue_declare(&#39;hello&#39;, false, true, false, false);你现在如果需要一个持久化的队列，则需要从新定义。将hello替换一下名字就好了。$channel-&gt;queue_declare(&#39;harlan&#39;, false, true, false, false); no exchange ‘supply_exchange’ in vhost ‘/‘在发布者执行发布消息的时候报交换机不存在，这样将导致你的消息丢失。 一般创建交换机的代码在消费端，所以在运行发布端之前先执行消费端程序；$channel-&gt;exchange_declare(&#39;supply_exchange&#39;, &#39;fanout&#39;, false, false, false); inequivalent arg ‘type’ for exchange ‘supply_exchange’ in vhost ‘/‘: received ‘direct’ but current is ‘fanout’交换机一旦创建了就不能在修改type类型。 如果想用不同类型的交换机就需要重新创建$channel-&gt;exchange_declare(&#39;supply_exchange&#39;, &#39;direct&#39;, false, false, false); 参考 RabbitMQ遇到的坑]]></content>
      <categories>
        <category>rabbitmq</category>
      </categories>
      <tags>
        <tag>rabbitmq</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rabbitMQ 安装教程]]></title>
    <url>%2Fposts%2Frabbitmq%2Fa3479b5d.html</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;中间有段时间了解过消息队列，利用它们可以做很多事情，一般都广泛应用于需要异步处理的程序上。现在成型的队列有很多，其中有rabbitmq，beanstalkd等等，他们各有千秋。今天在centos 7上安装rabbitMQ记录一下。 官方安装简介&emsp;&emsp;基于RPM的Linux（RedHat Enterprise Linux，CentOS，Fedora，openSUSE） 上的RabbitMQ安装。RabbitMQ包含在标准Fedora和RHEL存储库中。但是，其中包含的版本通常是过时的，并且不再受支持。 有两种方法可以安装最新版本的RabbitMQ： 使用Package Cloud或Bintray上的Yum存储库安装软件包（强烈建议使用此选项） 下载软件包并使用rpm安装。此选项将需要手动安装所有软件包依赖项。 官方地址：rabbitMQ 安装教程 安装注意：erlang需要和rabbitmq的版本要匹配，RabbitMQ Erlang版本要求 安装ErlangrabbitMQ是erlang语言开发的，所以在安装之前必须要安装erlang依赖 使用官方提供的脚本进行安装：erlang Installation instructions1curl -s https://packagecloud.io/install/repositories/rabbitmq/erlang/script.rpm.sh | sudo bash 运行该脚本后会得到一个/etc/yum.repos.d/rabbitmq_erlang.repo包文件; 运行yum install erlang进行安装。中间如果有提示输入y等待安装完成就行了; 测试是否安装成功：erl; 安装rabbitMQ跟erlang安装是一样的操作使用官方提供的脚本进行安装：rabbitMQ Installation instructions1curl -s https://packagecloud.io/install/repositories/rabbitmq/rabbitmq-server/script.rpm.sh | sudo bash 运行该脚本后会得到一个/etc/yum.repos.d/rabbitmq_rabbitmq-server.repo包文件; 运行yum install rabbitmq-server进行安装。中间如果有提示输入y等待安装完成就行了; 执行rabbitMQ的基本命令设置守护进程，系统启动时执行systemctl enable rabbitmq-server 启动systemctl start rabbitmq-server 停止systemctl stop rabbitmq-server 安装管理界面rabbitmq_managementrabbitmq-plugins enable rabbitmq_management 重启rabbitmq/sbin/service rabbitmq-server restart 查看http服务开启rabbitmqctl status 查看已经存在的用户rabbitmqctl list_users 新建用户rabbitmqctl add_user admin admin 授权rabbitmqctl set_user_tags admin administrator 参考 Installing on RPM-based Linux (RedHat Enterprise Linux, CentOS, Fedora, openSUSE) RabbitMQ Erlang版本要求 RabbitMA Installation instructions Erlang Installation instructions RabbitMQ安装和卸载 CentOS7安装RabbitMQ3.7]]></content>
      <categories>
        <category>rabbitmq</category>
      </categories>
      <tags>
        <tag>rabbitmq</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决ERROR 2006 (HY000): MySQL server has gone away]]></title>
    <url>%2Fposts%2Fmysql%2Fe5995b09.html</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;今天在做地址4级联动的时候，由于一次性全部取出数据导致报：SQLSTATE[HY000]: General error: 2006 MySQL server has gone away。于是在网上寻找相关的解决方案，发现是因为超过了mysql默认的数据包。 解决方案 登录mysql查询设置最大的数据包值1234567mysql&gt; show global variables like 'max_allowed_packet';+--------------------+---------+| Variable_name | Value |+--------------------+---------+| max_allowed_packet | 1048576 |+--------------------+---------+1 row in set (0.01 sec) 上限是1M，mysql的默认配置。 修改配置，设置为16M1set global max_allowed_packet = 1024 * 1024 * 16; 注意：以上命令修改值针对当前有效，mysql重启后还会变成默认值1M。 永久有效，修改配置文件 my.ini1max_allowed_packet = 16M 注意：修改完ini配置千万不要忘记重启哦，或者从新加载配置文件！ 参考 解决ERROR 2006 (HY000): MySQL server has gone away]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2020最新PhpStorm激活码]]></title>
    <url>%2Fposts%2Fphpstorm%2F6608d634.html</url>
    <content type="text"><![CDATA[最新激活码有效期至2021年1月4号（亲测可用）特别感谢：桔子的桔子原文连接：2020年PHPstorm 最新激活码1QYYBAC9D3J-eyJsaWNlbnNlSWQiOiJRWVlCQUM5RDNKIiwibGljZW5zZWVOYW1lIjoi6LaF57qnIOeoi+W6j+WRmCIsImFzc2lnbmVlTmFtZSI6IiIsImFzc2lnbmVlRW1haWwiOiIiLCJsaWNlbnNlUmVzdHJpY3Rpb24iOiIiLCJjaGVja0NvbmN1cnJlbnRVc2UiOmZhbHNlLCJwcm9kdWN0cyI6W3siY29kZSI6IklJIiwiZmFsbGJhY2tEYXRlIjoiMjAyMC0wMS0wNCIsInBhaWRVcFRvIjoiMjAyMS0wMS0wMyJ9LHsiY29kZSI6IkFDIiwiZmFsbGJhY2tEYXRlIjoiMjAyMC0wMS0wNCIsInBhaWRVcFRvIjoiMjAyMS0wMS0wMyJ9LHsiY29kZSI6IkRQTiIsImZhbGxiYWNrRGF0ZSI6IjIwMjAtMDEtMDQiLCJwYWlkVXBUbyI6IjIwMjEtMDEtMDMifSx7ImNvZGUiOiJQUyIsImZhbGxiYWNrRGF0ZSI6IjIwMjAtMDEtMDQiLCJwYWlkVXBUbyI6IjIwMjEtMDEtMDMifSx7ImNvZGUiOiJHTyIsImZhbGxiYWNrRGF0ZSI6IjIwMjAtMDEtMDQiLCJwYWlkVXBUbyI6IjIwMjEtMDEtMDMifSx7ImNvZGUiOiJETSIsImZhbGxiYWNrRGF0ZSI6IjIwMjAtMDEtMDQiLCJwYWlkVXBUbyI6IjIwMjEtMDEtMDMifSx7ImNvZGUiOiJDTCIsImZhbGxiYWNrRGF0ZSI6IjIwMjAtMDEtMDQiLCJwYWlkVXBUbyI6IjIwMjEtMDEtMDMifSx7ImNvZGUiOiJSUzAiLCJmYWxsYmFja0RhdGUiOiIyMDIwLTAxLTA0IiwicGFpZFVwVG8iOiIyMDIxLTAxLTAzIn0seyJjb2RlIjoiUkMiLCJmYWxsYmFja0RhdGUiOiIyMDIwLTAxLTA0IiwicGFpZFVwVG8iOiIyMDIxLTAxLTAzIn0seyJjb2RlIjoiUkQiLCJmYWxsYmFja0RhdGUiOiIyMDIwLTAxLTA0IiwicGFpZFVwVG8iOiIyMDIxLTAxLTAzIn0seyJjb2RlIjoiUEMiLCJmYWxsYmFja0RhdGUiOiIyMDIwLTAxLTA0IiwicGFpZFVwVG8iOiIyMDIxLTAxLTAzIn0seyJjb2RlIjoiUk0iLCJmYWxsYmFja0RhdGUiOiIyMDIwLTAxLTA0IiwicGFpZFVwVG8iOiIyMDIxLTAxLTAzIn0seyJjb2RlIjoiV1MiLCJmYWxsYmFja0RhdGUiOiIyMDIwLTAxLTA0IiwicGFpZFVwVG8iOiIyMDIxLTAxLTAzIn0seyJjb2RlIjoiREIiLCJmYWxsYmFja0RhdGUiOiIyMDIwLTAxLTA0IiwicGFpZFVwVG8iOiIyMDIxLTAxLTAzIn0seyJjb2RlIjoiREMiLCJmYWxsYmFja0RhdGUiOiIyMDIwLTAxLTA0IiwicGFpZFVwVG8iOiIyMDIxLTAxLTAzIn0seyJjb2RlIjoiUlNVIiwiZmFsbGJhY2tEYXRlIjoiMjAyMC0wMS0wNCIsInBhaWRVcFRvIjoiMjAyMS0wMS0wMyJ9XSwiaGFzaCI6IjE2MDgwOTA5LzAiLCJncmFjZVBlcmlvZERheXMiOjcsImF1dG9Qcm9sb25nYXRlZCI6ZmFsc2UsImlzQXV0b1Byb2xvbmdhdGVkIjpmYWxzZX0=-I7c5mu4hUCMxcldrwZEJMaT+qkrzrF1bjJi0i5QHcrRxk2LO0jqzUe2fBOUR4L+x+7n6kCwAoBBODm9wXst8dWLXdq179EtjU3rfJENr1wXGgtef//FNow+Id5iRufJ4W+p+3s5959GSFibl35YtbELELuCUH2IbCRly0PUBjitgA0r2y+9jV5YD/dmrd/p4C87MccC74NxtQfRdeUEGx87vnhsqTFH/sP4C2VljSo/F/Ft9JqsSlGfwSKjzU8BreYt1QleosdMnMK7a+fkfxh7n5zg4DskdVlNbfe6jvYgMVE16DMXd6F1Zhwq+lrmewJA2jPToc+H5304rcJfa9w==-MIIElTCCAn2gAwIBAgIBCTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE4MTEwMTEyMjk0NloXDTIwMTEwMjEyMjk0NlowaDELMAkGA1UEBhMCQ1oxDjAMBgNVBAgMBU51c2xlMQ8wDQYDVQQHDAZQcmFndWUxGTAXBgNVBAoMEEpldEJyYWlucyBzLnIuby4xHTAbBgNVBAMMFHByb2QzeS1mcm9tLTIwMTgxMTAxMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxcQkq+zdxlR2mmRYBPzGbUNdMN6OaXiXzxIWtMEkrJMO/5oUfQJbLLuMSMK0QHFmaI37WShyxZcfRCidwXjot4zmNBKnlyHodDij/78TmVqFl8nOeD5+07B8VEaIu7c3E1N+e1doC6wht4I4+IEmtsPAdoaj5WCQVQbrI8KeT8M9VcBIWX7fD0fhexfg3ZRt0xqwMcXGNp3DdJHiO0rCdU+Itv7EmtnSVq9jBG1usMSFvMowR25mju2JcPFp1+I4ZI+FqgR8gyG8oiNDyNEoAbsR3lOpI7grUYSvkB/xVy/VoklPCK2h0f0GJxFjnye8NT1PAywoyl7RmiAVRE/EKwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl/GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQAF8uc+YJOHHwOFcPzmbjcxNDuGoOUIP+2h1R75Lecswb7ru2LWWSUMtXVKQzChLNPn/72W0k+oI056tgiwuG7M49LXp4zQVlQnFmWU1wwGvVhq5R63Rpjx1zjGUhcXgayu7+9zMUW596Lbomsg8qVve6euqsrFicYkIIuUu4zYPndJwfe0YkS5nY72SHnNdbPhEnN8wcB2Kz+OIG0lih3yz5EqFhld03bGp222ZQCIghCTVL6QBNadGsiN/lWLl4JdR3lJkZzlpFdiHijoVRdWeSWqM4y0t23c92HXKrgppoSV18XMxrWVdoSM3nuMHwxGhFyde05OdDtLpCv+jlWf5REAHHA201pAU6bJSZINyHDUTB+Beo28rRXSwSh3OUIvYwKNVeoBY+KwOJ7WnuTCUq1meE6GkKc4D/cXmgpOyW/1SmBz3XjVIi/zprZ0zf3qH5mkphtg6ksjKgKjmx1cXfZAAX6wcDBNaCL+Ortep1Dh8xDUbqbBVNBL4jbiL3i3xsfNiyJgaZ5sX7i8tmStEpLbPwvHcByuf59qJhV/bZOl8KqJBETCDJcY6O2aqhTUy+9x93ThKs1GKrRPePrWPluud7ttlgtRveit/pcBrnQcXOl1rHq7ByB8CFAxNotRUYL9IF5n3wJOgkPojMy6jetQA5Ogc8Sm7RG6vg1yow==]]></content>
      <categories>
        <category>phpstorm</category>
      </categories>
      <tags>
        <tag>phpstorm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JWT 学习笔记]]></title>
    <url>%2Fposts%2Fphp%2Fd9c65851.html</url>
    <content type="text"><![CDATA[简介&emsp;&emsp;JWT 是什么？JWT是json web token缩写。它将用户信息加密到token里，服务器不保存任何用户信息。服务器通过使用保存的密钥验证token的正确性，只要正确即通过验证。基于token的身份验证可以替代传统的cookie+session身份验证方法。使用流程：初次登录：用户初次登录，输入用户名密码；密码验证：服务器从数据库取出用户名和密码进行验证；生成JWT：服务器端验证通过，根据从数据库返回的信息，以及预设规则，生成JWT；返还JWT：服务器的HTTP RESPONSE中将JWT返还；带JWT的请求：以后客户端发起请求，HTTP REQUEST；HEADER中的Authorizatio字段都要有值，为JWT；服务器验证JWT； JWTJWT由三个部分组成：header.payload.signature header1234&#123; "alg": "HS256", "typ": "JWT"&#125; 说明：该字段为json格式。alg：字段指定了生成signature的算法，默认值为：HS256，typ：默认值为：JWT payload12345&#123; "sub": "1234567890", "name": "John Doe", "iat": 1516239022&#125; 说明：该字段为json格式，表明用户身份的数据，可以自己自定义字段，很灵活。sub：面向的用户iat：签发时间iss：该JWT的签发者exp：过期时间nbf：该时间之前不接收处理该Tokenjti：该Token唯一标识name：（自定义字段）姓名 signature12345HMACSHA256( base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(payload), secret) 说明：将前两部分进行base64编码后使用.拼接成待加密字符串，secret是加密的密钥；加密方式需要在 header 指定，有好多种：HS256，HS384，RS256 等。 实践代码注意：php版本 &gt;= 7.0.* 类封装：jwt.class.php123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126&lt;?php/** * PHP实现jwt * 作者：https://segmentfault.com/a/1190000016251365 */class Jwt &#123; //头部 private static $header=array( 'alg'=&gt;'HS256', //生成signature的算法 'typ'=&gt;'JWT' //类型 ); //使用HMAC生成信息摘要时所使用的密钥 private static $key='123456'; /** * 获取jwt token * @param array $payload jwt载荷 格式如下非必须 * [ * 'iss'=&gt;'jwt_admin', //该JWT的签发者 * 'iat'=&gt;time(), //签发时间 * 'exp'=&gt;time()+7200, //过期时间 * 'nbf'=&gt;time()+60, //该时间之前不接收处理该Token * 'sub'=&gt;'www.admin.com', //面向的用户 * 'jti'=&gt;md5(uniqid('JWT').time()) //该Token唯一标识 * ] * @return bool|string */ public static function getToken(array $payload) &#123; if(is_array($payload)) &#123; $base64header=self::base64UrlEncode(json_encode(self::$header,JSON_UNESCAPED_UNICODE)); $base64payload=self::base64UrlEncode(json_encode($payload,JSON_UNESCAPED_UNICODE)); $token=$base64header.'.'.$base64payload.'.'.self::signature($base64header.'.'.$base64payload,self::$key,self::$header['alg']); return $token; &#125;else&#123; return false; &#125; &#125; /** * 验证token是否有效,默认验证exp,nbf,iat时间 * @param string $Token 需要验证的token * @return bool|string */ public static function verifyToken(string $Token) &#123; $tokens = explode('.', $Token); if (count($tokens) != 3) return false; list($base64header, $base64payload, $sign) = $tokens; //获取jwt算法 $base64decodeheader = json_decode(self::base64UrlDecode($base64header), JSON_OBJECT_AS_ARRAY); if (empty($base64decodeheader['alg'])) return false; //签名验证 if (self::signature($base64header . '.' . $base64payload, self::$key, $base64decodeheader['alg']) !== $sign) return false; $payload = json_decode(self::base64UrlDecode($base64payload), JSON_OBJECT_AS_ARRAY); //签发时间大于当前服务器时间验证失败 if (isset($payload['iat']) &amp;&amp; $payload['iat'] &gt; time()) return false; //过期时间小宇当前服务器时间验证失败 if (isset($payload['exp']) &amp;&amp; $payload['exp'] &lt; time()) return false; //该nbf时间之前不接收处理该Token if (isset($payload['nbf']) &amp;&amp; $payload['nbf'] &gt; time()) return false; return $payload; &#125; /** * base64UrlEncode https://jwt.io/ 中base64UrlEncode编码实现 * @param string $input 需要编码的字符串 * @return string */ private static function base64UrlEncode(string $input) &#123; return str_replace('=', '', strtr(base64_encode($input), '+/', '-_')); &#125; /** * base64UrlEncode https://jwt.io/ 中base64UrlEncode解码实现 * @param string $input 需要解码的字符串 * @return bool|string */ private static function base64UrlDecode(string $input) &#123; $remainder = strlen($input) % 4; if ($remainder) &#123; $addlen = 4 - $remainder; $input .= str_repeat('=', $addlen); &#125; return base64_decode(strtr($input, '-_', '+/')); &#125; /** * HMACSHA256签名 https://jwt.io/ 中HMACSHA256签名实现 * @param string $input 为base64UrlEncode(header).".".base64UrlEncode(payload) * @param string $key * @param string $alg 算法方式 * @return mixed */ private static function signature(string $input, string $key, string $alg = 'HS256') &#123; $alg_config=array( 'HS256'=&gt;'sha256' ); return self::base64UrlEncode(hash_hmac($alg_config[$alg], $input, $key,true)); &#125;&#125; 调用：1234567891011121314151617181920212223&lt;?php/** * PHP实现jwt * 作者：https://segmentfault.com/a/1190000016251365 */require "jwt.class.php";$payload_test=array( 'iss' =&gt; 'admin', 'iat' =&gt; time(), 'exp' =&gt; time()+7200, 'nbf' =&gt; time(), 'sub' =&gt; 'www.admin.com', 'jti' =&gt; md5(uniqid('JWT').time()));$token_test = Jwt::getToken($payload_test);echo $token_test;echo "&lt;br&gt;";// 验证token签名$getPayload_test=Jwt::verifyToken($token_test);var_dump($getPayload_test); 参考 php 后端实现JWT认证方法]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>JWT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git学习之路]]></title>
    <url>%2Fposts%2Fgit%2F113d1d94.html</url>
    <content type="text"><![CDATA[简介Git是一个免费的开源 分布式版本控制系统，旨在快速，高效地处理从小型到大型项目的所有事务。Git 易于学习， 占地面积小，具有闪电般快速的性能。它超越了Subversion，CVS，Perforce和ClearCase等SCM工具，具有廉价的本地分支，便捷的临时区域和 多个工作流程等功能。 Download 下载下载地址：官网git download 官方文档：Documentation 提示：具体的安装方法去看一下 官方文档 ，里面写的安装步骤很详细。 命令行使用 GIT直接在已有项目的文件里提交项目进入到项目文件夹下，打开 cmd 命令行 提示：这里推荐大家使用 cmder 命令行工具，个人感觉在敲命令的时候很舒服。 初始化 1git init 这个时候你会在你的项目文件夹下面看到一个 .git 的隐藏文件 提示：看不到说明你没勾选文件夹 隐藏的项目 。 点击文件夹上面的 查看 -&gt; 隐藏的项目（勾选上） 和远程建立连接 1git remote add &lt;dev&gt; &lt;url&gt; dev ：远程仓库的名字（别名，随便起） url ：远程仓库的地址（https ， ssh 都行） 获取远程分支 1git fetch &lt;dev&gt; dev ：上一步仓库的别名 查看远程分支 1git branch -a 将远程的分支检出到本地并切换到新的分支 1git checkout -b &lt;thisBranch&gt; &lt;dev&gt;/&lt;branchName&gt; -b ：新建一个分支并同时切换到那个分支上 thisBranch ：本地分支的名称 dev ：远程仓库别名 branchName ：远程分支名称 提示：这一步建议 thisBranch 和 branchName 保持一致注意：如果出现 fatal: ‘thisBranch’ is not a commit and a branch ‘thisBranch’ cannot be created from it 错误，说明远程分支不存在，仔细检测一下 &lt;dev&gt;/&lt;branchName&gt;。 这个时候我们可以使用 git status 查看当前仓库那些文件没有被跟踪和变化。 添加未跟踪的文件为跟踪状态 1git add . . ：当前仓库所有未跟踪的文件 提交 1git commit -m "commit content" -m ： 本次提交的内容 这里 7，8 可以合并成一句执行，但是这里只能提交未跟踪的文件，已跟踪的文件修改后将不会被提交git commit -a -m &quot;commit content&quot; 推送到远程仓库 1git push 这个时候我们在浏览器上打开远程仓库可以看到刚刚提交的内容了。 通过远程拉取代码时，这里使用的是 clone 的方式 新建一个干净的文件夹并且进入到该文件夹，执行下面的命令 1git clone &lt;url&gt; url ： 远程项目仓库的地址 查看远程仓库的分支 1git branch -a 拉取远程分支到本地并自动切换到该分支 1git checkout -b &lt;thisBranch&gt; &lt;dev&gt;/&lt;branchName&gt; 这里我就不多做解释了，在文章的上面都有想对应的说明。 下面就可以开始你的项目开发了。 注意：提交后别忘记 push ，否则无法把最新的代码推送到远程仓库里去 参考 git官方文档 git 拉取远程指定分支 pull本地不存在的分支 git命令－切换分支 为已经存在的本地项目添加git，以及从远程仓库拉取代码并切换远程分支]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP使用ffmpeg实现截取视频封面图]]></title>
    <url>%2Fposts%2Fffmpeg%2F4ef34b77.html</url>
    <content type="text"><![CDATA[前言本篇文章将带您学习如何使用 ffmpeg 实现截取视频封面图保存到本地，以及在 Linux 安装ffmpeg 的过程。 ffmpeg 介绍ffmpeg 是一个很强大的音视频处理工具，官网 介绍ffmpeg是：一个完整的、跨平台的解决方案，可以记录、转换和传输音频和视频。ffmpeg 既可以播放视频，也提供命令行工具来处理视频，另外还有强大的视频处理库用于开发。 Linux 安装 ffmpeg下载安装 ffmpeg去 ffmpeg 官网 下载4.0.3 安装包。 下载之后上传至Linux准备安装，首先解压安装包 123tar -xjvf ffmpeg-3.3.1.tar.bz2cd ffmpeg-3.3.1/./configure --enable-shared --prefix=/monchickey/ffmpeg 注意：如果现在直接执行configure配置的话，可能会报如下的错误：yasm/nasm not found or too old. Use –disable-yasm for a crippled build.错误的意思是 yasm/nasm 包不存在或者很旧，可以使用--disable-yasm禁用这个选项编译也可以按照下面的步骤进行安装yasm。 下载安装 yasm yasm是一款汇编器，并且是完全重写了nasm的汇编环境，接收nasm和gas语法，支持x86和amd64指令集。 安装yasm：yasm 安装地址 下载完成后传到服务器上进行安装，下面是安装方法（这里我安装的是 1.3.0） 12345tar -xvzf yasm-1.3.0.tar.gzcd yasm-1.3.0/./configuremakemake install 编译参数都是默认的，直接安装到系统中即可。 继续安装 ffmpegyasm安装成功之后继续回到ffmpeg解压后的目录，执行下面命令编译并安装：123./configure --enable-shared --prefix=/monchickey/ffmpegmakemake install 这个编译的过程时间可能有点长，这时候我们可以去泡杯咖啡了。 安装完成之后进入到安装目录：cd /monchickey/ffmpeg/.├─ ffmpeg├─── bin // ffmpeg主程序二进制目录├─── include // C/C++头文件目录├─── lib // 编译好的库文件目录├─── share // 文档目录进入bin目录，执行 ./ffmpeg -version 查看当前版本的详细信息 默认情况下一般会报：libavdevice.so.57: cannot open shared object file: No such file or directory 原因是lib目录未加载到链接到系统库中，系统ld目录列表在/etc/ld.so.conf中，打开文件会发现，里面引用了/etc/ld.so.conf.d/下面所有的.conf文。 这时我们只需要创建一个文件并写入lib路径即可，执行命令：vim /etc/ld.so.conf.d/ffmpeg.conf 然后添加一行内容：/monchickey/ffmpeg/lib 之后保存并退出，然后执行 ldconfig 使配置生效，现在再次执行 ./ffmpeg -version 显示就正常了提示：可以根据需要将bin目录添加至环境变量中以保证任何时候都能使用ffmpeg命令 使用php代码实现视频封面图截取123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124/** * 上传视频 * @return 视频路径 */function upload_video()&#123; if ($_FILES["file"]["error"] &gt; 0) &#123; $api-&gt;dataerror('视频上传错误!'); &#125; else &#123; $type = [ "video/rmvb", "video/wmv", "video/3gp", "video/mkv", "video/mp4", "video/mpg", "video/avi", "video/quicktime", "multipart/video", ]; if (in_array($_FILES["file"]["type"], $type)) &#123; if($_FILES["file"]["size"] &lt;= 20 * 1024 * 1024) &#123; $upload_path = 'uploads/video/file_name'; //建立文件夹 create($upload_path); $file_name = md5(uniqid(rand())); // 文件随机名字 $file_ext = strtolower(substr($_FILES["file"]["name"], strrpos($_FILES["file"]["name"], ".") + 1, strlen($_FILES["file"]["name"]))); // 获取文件后缀 $upload_path_file = $upload_path . $file_name . '.' . $file_ext; if (file_exists($upload_path_file)) &#123; echo '视频文件名以被占用, 请重新上传!'; &#125; else &#123; if (move_uploaded_file($_FILES["file"]["tmp_name"], $upload_path_file)) &#123; $video_path = $upload_path_file; // 视频路径 $item['video_path'] = $video_path; $face_name = $upload_path . $file_name . '.' . 'png'; //视频封面图 $pic_size = getVideoInfo($video_path); if ($pic_size['2'] &gt; 0) &#123; $str = "/monchickey/ffmpeg/bin/ffmpeg -i " . $video_path . " -y -f mjpeg -ss 1 -t 0.001 -s " . $pic_size[1] . "x" . $pic_size[0] . " " . $face_name; &#125; else &#123; $str = "/monchickey/ffmpeg/bin/ffmpeg -i " . $video_path . " -y -f mjpeg -ss 1 -t 0.001 -s " . $pic_size[0] . "x" . $pic_size[1] . " " . $face_name; &#125; system($str); if (file_exists($face_name)) &#123; $item['video_face_image'] = $name; &#125;else &#123; echo "视频封面图截取失败!"; &#125; return $item; &#125; else &#123; echo "视频文件上传失败!"; &#125; &#125; &#125;else &#123; echo "视频最大不能超过20M!"; &#125; &#125; else &#123; echo "视频格式错误!"; &#125; &#125;&#125;/** * 创建文件夹 * @param $dir 文件夹路径 */function create($dir)&#123; if( !is_dir($dir) )&#123; $temp = explode('/',$dir); $cur_dir = ''; for($i = 0; $i &lt; count($temp); $i++)&#123; $cur_dir .= $temp[$i].'/'; if(!is_dir($cur_dir))&#123; @mkdir($cur_dir,0777); &#125; &#125; &#125;&#125;/** * 处理视频文件文件截取封面图的信息 * @param $file 视频文件路径 */function getVideoInfo($file)&#123; $command = sprintf('/monchickey/ffmpeg/bin/ffmpeg -i "%s" 2&gt;&amp;1', $file); ob_start(); passthru($command); $info = ob_get_contents(); ob_end_clean(); if (preg_match("/Video: (.*?),(.*?),(.*?),(.*?),(.*?),(.*?),(.*?),(.*?)[,\s]/", $info, $match)) &#123; foreach ($match as $k =&gt; $m) &#123; if (strstr($m, 'x') &amp;&amp; $k &gt; 0) &#123; $size1 = explode('x', trim($m)); if (preg_match("/^\d*$/", $size1[0])) &#123; $size[0] = $size1[0]; if (preg_match("/^\d*$/", $size1[1])) &#123; $size[1] = $size1[1]; &#125; else &#123; $size2 = explode(' ', trim($size1[1])); $size[1] = $size2[0]; &#125; &#125; &#125; &#125; &#125; if (preg_match("/Side data:[,\s]/", $info, $match2)) &#123; $size[2] = 1; &#125; return $size;&#125; 参考 博客园 - 自由的web]]></content>
      <categories>
        <category>ffmpeg</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>ffmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[phpstorm配置Xdebug]]></title>
    <url>%2Fposts%2Fxdebug%2F8d586dc9.html</url>
    <content type="text"><![CDATA[前言相信做为一名PHP开发的程序员对sublime这个编辑器不陌生吧，我之前用的就是这个编辑器，在每次有BUG反馈过来的时候，我都是用die去一步一步的断点打印输出找错误，看着是不是就很痛苦。后来知道了 phpstorm + xdebug，欣喜若狂，这简直是款调试代码的神器呀，幸福来的好突然。后来这篇文章就诞生了。 声明本篇文章将讲述的是如何使用 xdebug 配合 phpstorm 编辑器调试PHP程序 兼容 postman 什么是Xdebug?Xdebug是一个开放源代码的PHP程序调试器(即一个Debug工具)，可以用来跟踪，调试和分析PHP程序的运行状况。 下载安装 下载 phpstorm 至于怎么去破解我想 这里 可以帮助你 下载对应版本的 Xdebug扩展 开始配置配置编辑器的php打开已经破解好的 phpstorm 的设置，找到 Languages &amp; Frameworks -&gt; PHP 选择自己当前正在使用的版本。 配置ServersName 随便填写，Host 和 Port 填写自己需要调试的项目域名以及端口，Debugger 默认的Xdebug就行 点击 Languages &amp; Frameworks -&gt; PHP -&gt; Debug 将Debug port 修改为 9001 点击 Languages &amp; Frameworks -&gt; PHP -&gt; Debug -&gt; DBGp Proxy 将IDE KEY换成当前PHP的IDE KEY填上自己网站的 host 和 port 查看IDE KEY需要打印自己的PHP信息echo phpinfo();然后在这里面找IDE KEY 配置 php.ini打开 php.ini 在最底部添加以下代码 1234567891011121314[xdebug]; XDEBUG Extension DLLzend_extension ="D:/wamp64/bin/php/php5.6.31/zend_ext/php_xdebug-2.5.5-5.6-vc11-x86_64.dll";xdebug.idekey="PHPSTORM"xdebug.remote_enable = onxdebug.profiler_enable = offxdebug.profiler_enable_trigger = offxdebug.profiler_output_name = cachegrind.out.%t.%pxdebug.profiler_output_dir ="D:/wamp64/tmp"xdebug.show_local_vars=0xdebug.remote_handler = dbgp; 设置xdebug的端口为9001, 要和编辑器设置的一致哦xdebug.remote_port = "9001" 安装chrome xdebug helper 扩展扩展地址： xdebug helper 运行监听配置（这步配置配置的是为了编辑器里的run需要的，在postman调试可以忽略此步骤）按照下图的配置完成后点击OK 开启监听 点击上面带虫子的小话筒 运行点击编辑器上面的小瓢虫，这时会自动弹出编辑器代码断点的地方，并打印了上面的变量 兼容 postman在项目中使用 postman 调试的时候在 header 添加如下配置 12KEY : CookieVALUE : XDEBUG_SESSION=PHPSTORM 点击 Send 后效果跟上面是一样的，自动弹出编辑器跳到断点的地方。]]></content>
      <categories>
        <category>xdebug</category>
      </categories>
      <tags>
        <tag>phpstorm</tag>
        <tag>Xdebug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安装配置hexo，部署+next主题]]></title>
    <url>%2Fposts%2Fhexo%2Fc14c7c98.html</url>
    <content type="text"><![CDATA[文章由来 以前没有写博客的习惯，也没写过几篇博客。之前有一次工作中找同事问一个前端问题，跑到他的办公桌前偶然的发现了这个”东西”。第一眼看上去给我的个人感觉很好，经过我对同事的仔细盘问后，在加以私下的了解，才知道这个博客是用 hexo + next主题 搭建的。废话不多说了，Follow Me ! 安装安装前提在安装前，先确保电脑上已经安装了 Node.js 和 Git 环境。 安装Hexo1$ npm install -g hexo-cli 官方文档上是使用npm安装的，使用 yarn 安装：使用 Hexo 和 Github 快速搭建个人博客 。 建站初始化新建一个文件夹，名字随便起，比如我的叫 blog进入到新建的文件夹输入以下命令 1$ hexo init 初始化完成后，你会看到这样的一个文件目录结构 创建一个文件1$ hexo new post 第一篇文章 //在_post文件夹下创建一个名为 《第一篇文章》 的文件 生成静态文件1$ hexo generate // 简写 hexo g 启动服务1$ hexo server // 简写 hexo s 以上命令会生成一个 localhost:4000 的连接， 打开连接会看到自己博客的首页。 部署到线上GitHub，Gitee和Coding等都支持Hexo静态网站的服务，我用的是Gitee。 首先到你的Gitee 上去建立一个仓库，仓库名称最好是你自己的英文名称或者自创的名称，仓库创建好后，复制仓库的地址 打开站点的 _config.yml 配置文件，找到最下面的 deploy 选项. 123deploy: type: git repo: https://gitee.com/*** // 刚刚创建的仓库连接地址 注意：冒号后面一定要有一个空格 安装 hexo-deployer-git 自动部署工具。 1$ npm install hexo-deployer-git --save 上传到线上安装完成自动部署工具后，使用命令上传到线上 1$ hexo deploy // 简写 hexo d 第一次上传会提示你输入GitHub 或者 Gitee 的账号密码，确认后等待一会会提示你发布成功；这时打开码云，找到刚刚项目分支，点击服务选择Gitee Pages，然后就可以看到线上的一个连接。点击进入连接 https://hsweet.gitee.io 就可以看到线上的博客了。 注意：项目部署到Gitee上后每次都需要手动去更新，如果需要自动部署更新的话需购买 Gitee Pages Pro（￥99/年） 主题（将持续更新…）安装Next主题1$ git clone https://github.com/theme-next/hexo-theme-next themes/next 我安装的是 6.0.x 的 NexT ，但在 NexT 官网上提供的还是 5.1.x 的安装命令和文档，因为 6.0.x 和 5.1.x 的配置有所不同，建议第一次练习搭建还是使用 5.1.x ，熟悉配置文档后，再用 6.0.x 。 修改 _config.yml 文件里 theme 配置： 1theme: next 配置虽然我安装的是 6.0.x ，但大部分还是可以根据 NexT 主题配置 文档来修改，以下会介绍一些文档中没有提及的设置。 区分两个配置文件 :站点配置文件 _config.yml主题配置文件 themes/next/_config.yml 设置网站语言打开 站点配置 找到 language 修改 1language: zh-CN 开启导航打开 主题配置 找到 menu ，将需要开启的导航前面的 # 删掉 123456789menu: home: / || home // 首页 about: /about/ || user // 关于我 tags: /tags/ || tags // 标签 categories: /categories/ || th // 分类 archives: /archives/ || archive // 归档 #schedule: /schedule/ || calendar // 日程表 #sitemap: /sitemap.xml || sitemap // 站点地图 commonweal: /404.html || heartbeat // 404公益 这个时候会发现网站上已经能看到导航了，但点击却提示找不到页面。 这时需要去新建对应的页面，比如新建 标签 页： 1$ hexo new page "tags" 新建好后会在 source/tags/index.md 看到刚新建的文件，在文件随便增加一句话重新编译生成试试。 更多配置请参考文档 : Next主题官方文档 2020-04-05 主题优化在右上角或者左上角实现fork me on github点击这里或者这里挑选自己喜欢的样式，并复制代码。粘贴刚才复制的代码到themes/next/layout/_layout.swig文件中(放在&lt;div class=&quot;headband&quot;&gt;&lt;/div&gt;的下面)，并把href改为你的github地址 修改文章内链接文本样式修改文件 themes\next\source\css\_common\components\post\post.styl ，在末尾添加如下css样式:12345678910.post-body p a&#123; color: #0593d3; border-bottom: none; border-bottom: 1px solid #0593d3; &amp;:hover &#123; color: #fc6423; border-bottom: none; border-bottom: 1px solid #fc6423; &#125;&#125; 修改文章底部的带#号的标签修改模板 \themes\next\layout\_macro\post.swig，搜索 rel=&quot;tag&quot;&gt;#，将 # 换成 &lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt; 使用gulp对博文进行压缩 在站点的根目录下执行以下命令： 12$ npm install gulp -g$ npm install gulp-minify-css gulp-uglify gulp-htmlmin gulp-htmlclean gulp --save 在站点的根目录下新建 gulpfile.js 文件，将下面代码复制到新建的文件里去： 123456789101112131415161718192021222324252627282930313233var gulp = require('gulp');var minifycss = require('gulp-minify-css');var uglify = require('gulp-uglify');var htmlmin = require('gulp-htmlmin');var htmlclean = require('gulp-htmlclean');// 压缩 public 目录 cssgulp.task('minify-css', function() &#123; return gulp.src('./public/**/*.css') .pipe(minifycss()) .pipe(gulp.dest('./public'));&#125;);// 压缩 public 目录 htmlgulp.task('minify-html', function() &#123; return gulp.src('./public/**/*.html') .pipe(htmlclean()) .pipe(htmlmin(&#123; removeComments: true, minifyJS: true, minifyCSS: true, minifyURLs: true, &#125;)) .pipe(gulp.dest('./public'))&#125;);// 压缩 public/js 目录 jsgulp.task('minify-js', function() &#123; return gulp.src('./public/**/*.js') .pipe(uglify()) .pipe(gulp.dest('./public'));&#125;);// 执行 gulp 命令时执行的任务gulp.task('default', [ 'minify-html','minify-css','minify-js']); 在打包的时候是执行 hexo g &amp;&amp; gulp 就会根据 gulpfile.js 中的配置，对 public 目录中的静态资源文件进行压缩。 修改代码块自定义样式打开 \themes\next\source\css\_custom\custom.styl，向里面加入：(颜色可以自己定义)12345678910111213141516// Custom styles.code &#123; color: #ff7600; background: #fbf7f8; margin: 2px;&#125;// 大代码块的自定义样式.highlight, pre &#123; margin: 5px 0; padding: 5px; border-radius: 3px;&#125;.highlight, code, pre &#123; border: 1px solid #d6d6d6;&#125; 设置文章，菜单栏，评论区，分页，站点概况为透明打开 \themes\next\source\css\_custom\custom.styl，向里面加入：12345678910111213141516171819.post-block &#123; background: rgba(255,255,255,0.6) !important;&#125;.pagination &#123; background: rgba(255,255,255,0.6) !important;&#125;.sidebar &#123; opacity: 0.7; background: rgba(255,255,255,0.6) !important;&#125;.sidebar-inner &#123; background: rgba(255,255,255,0.6) !important;&#125;.comments &#123; background: rgba(255,255,255,0.6) !important;&#125;.header-inner &#123; background: rgba(255,255,255,0.6) !important;&#125; 设置3D雪花动画 在 \themes\next\source\js\src\ 新建一个newSnow.js文件，将这里的代码复制到刚新建的那个文件里 打开 \themes\next\layout\_layout.swig 找到&lt;/body&gt;闭合标签的上面增加以下代码： 12345&#123;% if theme.showNewSnow %&#125; &lt;script type="text/javascript" src="/js/src/newSnow.js"&gt;&lt;/script&gt; &lt;style type="text/css"&gt;.snow-container&#123;position:fixed;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:100001&#125;&lt;/style&gt; &lt;div class="snow-container"&gt;&lt;/div&gt;&#123;% endif %&#125; 在主题配置文件_config.yml最后面新增以下配置：（注意：是主题配置文件） 1showNewSnow: true 效果图： 更换博客背景图片打开 \themes\next\source\css\_custom\custom.styl，向里面加入：1234567body &#123; width:100%; height:100%; background:url("/images/snow_bg.jpg") no-repeat; background-size: cover; background-attachment:fixed;&#125; 总结每次新建，修改博文或修改配置的时候只需要以下四个命令就ok了。1234567$ hexo generate // 编译生成静态文件 简写: hexo g$ hexo server // 本地预览 简写: hexo s$ hexo deploy // 部署到git服务器 简写：hexo d$ hexo clean // 清除编译生成静态文件 参考 Hexo文档 Next主题文档 搭建hexo + next主题博客教程 Hexo-Next-Gemini主题透明化以及背景图片的更改和获取 Hexo Next 主题启用及相关设置]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
</search>
